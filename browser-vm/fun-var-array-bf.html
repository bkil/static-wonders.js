<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <title>JavaScript subset for Brainfuck interpreter: array, locals</title>
  <link rel='shortcut icon' type=image/x-icon href=data:image/x-icon;, />
  <meta property='og:description' content='Minimalist client side scripting experiment of gemini-web' name='description'>
  <meta name=viewport content='width=device-width, initial-scale=1'>
  <meta name=referrer content=no-referrer>
  <style>
html, body {
  height: 100%;
}

textarea {
  overflow-wrap: anywhere;
  width: 100%;
  height: 40%;
}

.error {
  background-color: #fcc;
}
  </style>
</head>
<body>

<h2>Program</h2>
<textarea id=source autofocus>
// <![CDATA[
function skipToLoopEnd(program, startPc) {
  var nest = 1;
  var pc = startPc - 1;
  while (nest > 0) {
    pc = pc + 1;
    if (pc >= program.length) {
      nest = 0
    } else if (program[pc] == "[") {
      nest = nest + 1
    } else if (program[pc] == "]") {
      nest = nest - 1
    }
  };
  return pc
}

function exec(program, read) {
  var pc = 0;
  var rp = 0;
  var output = "";

  var mem = [];
  mem[0] = 0;
  var mp = 0;
  var stack = [];
  var sp = 0;
  var c;
  var str;

  while (pc < program.length) {
    c = program[pc];
    pc = pc + 1;
    if (c == "<") {
      mp = mp - 1
    } else if (c == ">") {
      mp = mp + 1;
      if (mem[mp] > 0) {
        mp = mp
      } else {
        mem[mp] = 0
      }
    } else if (c == "+") {
      mem[mp] = mem[mp] + 1
    } else if (c == "-") {
      mem[mp] = mem[mp] - 1
    } else if (c == ",") {
      if (rp < read.length) {
        str = read[rp];
        mem[mp] = str.charCodeAt(0);
        rp = rp + 1
      } else {
        mem[mp] = 0
      }
    } else if (c == ".") {
      output = output + String.fromCharCode(mem[mp])
    } else if (c == "[") {
      stack[sp] = pc;
      sp = sp + 1;
      pc = skipToLoopEnd(program, pc)
    } else if (c == "]") {
      if (mem[mp] > 0) {
        pc = stack[sp - 1]
      } else {
        sp = sp - 1
      }
    }
  };
  return output
}

var output = exec(
  "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.,[+.,]",
  "aXY"
);
document.write(output)
// ]]>
</textarea>

<h2>Output</h2>
<textarea id=output></textarea>

<button id=runButton type=button disabled>Run</button>

<script>
// <![CDATA[
(function() {
'use strict';
var prog;
var symType;
var symValue;
var row;
var col;

function init() {
  var runBut = document.getElementById('runButton');
  runBut.onclick = run;
  runBut.disabled = false;
  run();
}

function run() {
  prog = document.getElementById('source').value;
  row = 0;
  col = 0;
  var out = document.getElementById('output');
  out.classList.remove('error');
  out.value = '';
  var tree = parseProgram();
  out.value = JSON.stringify(tree, null, 2) + '\n';
  evalFun('', [], tree, {});
}

function parseProgram() {
  var ret = {};
  nextSym();
  var mainBody = ['seq'];
  var isEnd = accept('');
  while (!isEnd) {
    if (accept('function')) {
      var name = expect('ident');
      expect('(');
      var param = [];
      if (!accept(')')) {
        do {
          param.push(expect('ident'));
        } while (accept(','));
        expect(')');
      }
      expect('{');
      var body = ['seq'];
      do {
        var statement;
        if (accept('return')) {
          statement = ['return', parseExpression()];
          isEnd = true;
        } else {
          statement = parseStatement();
          isEnd = !accept(';');
        }
        body.push(statement);
      } while (!isEnd);
      expect('}');
      isEnd = accept('');
      ret[name] = [param, body];
    } else {
      mainBody.push(parseStatement());
      isEnd = accept('');
      if (!isEnd) {
        expect(';');
      }
    }
  }
  ret[''] = [[], mainBody];
  return ret;
}

function evalFun(name, args, tree) {
  var fun = tree[name];
  if (!fun) {
    runError('unknown function ' + name);
  }
  if (fun[0].length !== args.length) {
    error('argument count mismatch for function ' + name);
  }
  var vars = {};
  for (var i = 0; i < args.length; i++) {
    vars[fun[0][i]] = args[i];
  }
  return evalStatement(fun[1], tree, vars);
}

function parseStatements() {
  var ret;
  if (accept('{')) {
    var ret = ['seq'];
    do {
      ret.push(parseStatement());
    } while (accept(';'));
    expect('}');
  } else {
    ret = parseStatement();
  }
  return ret;
}

function parseStatement() {
  var ret = [];
  if (accept('if')) {
    expect('(');
    var ifCond = parseExpression();
    expect(')');
    ret = ['if', ifCond, parseStatements()];
    if (accept('else')) {
      ret.push(parseStatements());
    }
  } else if (accept('while')) {
    expect('(');
    var whileCond = parseExpression();
    expect(')');
    ret = ['while', whileCond, parseStatements()];
  } else if (accept('var')) {
    ret = ['var', expect('ident')];
    if (accept('=')) {
      ret.push(parseExpression());
    }
  } else {
    ret = parseExpression();
  }
  return ret;
}

function evalStatement(statement, tree, vars) {
  var ret;
  switch (statement[0]) {
    case 'seq':
      for (var i = 1; i < statement.length; i++) {
        ret = evalStatement(statement[i], tree, vars);
      }
      break
    case 'return':
      ret = evalExpression(statement[1], tree, vars);
      break
    case 'if':
      if (evalExpression(statement[1], tree, vars)) {
        evalStatement(statement[2], tree, vars);
      } else if (statement[3]) {
        evalStatement(statement[3], tree, vars);
      }
      break
    case 'while':
      while (evalExpression(statement[1], tree, vars)) {
        evalStatement(statement[2], tree, vars);
      }
      break
    default:
      ret = evalExpression(statement, tree, vars);
  }
  return ret;
}

function parseExpression() {
  var ret = parseTerm();
  var value = accept('binop');
  if (value) {
    ret = [value, ret, parseTerm()];
  }
  return ret;
}

function parseTerm() {
  var ret = [];
  var value = accept('literal');
  if (value !== undefined) {
    ret = ['literal', value];
  } else if (accept('[')) {
    ret = ['[]'];
    expect(']');
  } else if (accept('(')) {
    ret = parseExpression();
    expect(')');
  } else if (value = accept('ident')) {
    var name = value;
    var method = accept('method');
    if (accept('(')) {
      var param = [];
      if (!accept(')')) {
        do {
          param.push(parseExpression());
        } while (accept(','));
        expect(')');
      }
      if (method) {
        ret = ['method', name, method, param];
      } else {
        ret = ['call', name, param];
      }
    } else {
      var idx;
      if (method) {
        ret = ['prop', name, method];
      } else {
        if (accept('[')) {
          idx = parseExpression();
          expect(']');
        }
        if (accept('=')) {
          if (idx) {
            ret = ['arrset', name, idx];
          } else {
            ret = ['set', name];
          }
          ret.push(parseExpression());
        } else {
          if (idx) {
            ret = ['arrget', name, idx];
          } else {
            ret = ['get', name];
          }
        }
      }
    }
  } else {
    expect('-term');
  }
  return ret;
}

function evalExpression(expr, tree, vars) {
  var e = function(i) {
    return evalExpression(expr[i], tree, vars);
  };
  var getVar = function(n) {
    if (vars.hasOwnProperty(n)) {
      return vars[n];
    }
    runError('trying to getVar undeclared variable ' + n);
  };
  var evalExprArgs = function(i) {
    return expr[i].map(function(x) { return evalExpression(x, tree, vars);});
  };

  switch (expr[0]) { // & | ^ ~
    case 'literal':
      return expr[1];
    case '[]':
      return [];
    case '==':
      return e(1) === e(2)
    case '!=':
      return e(1) !== e(2)
    case '<':
      return e(1) < e(2)
    case '<=':
      return e(1) <= e(2)
    case '>':
      return e(1) > e(2)
    case '>=':
      return e(1) >= e(2)
    case '+':
      return e(1) + e(2)
    case '-':
      return e(1) - e(2)
    case '*':
      return e(1) * e(2)
    case '/':
      return e(1) / e(2)
    case 'call':
      return evalFun(expr[1], evalExprArgs(2), tree);
    case 'prop':
      switch (expr[2]) {
        case 'length':
          return getVar(expr[1]).length;
        default:
          runError('unknown property on ' + expr[1] + ': ' + expr[2]);
      }
    case 'method':
      var a = evalExprArgs(3);
      switch (expr[1] + '.' + expr[2]) {
        case 'document.write':
          document.getElementById('output').value += a[0] + '\n';
          return
        case 'String.fromCharCode':
          return String.fromCharCode(a[0]);
        default:
          switch (expr[2]) {
            case 'charCodeAt':
              return getVar(expr[1]).charCodeAt(a[0]);
            default:
              runError('unknown method on ' + expr[1] + ': ' + expr[2]);
          }
      }
    case 'arrget':
      return getVar(expr[1])[e(2)];
    case 'arrset':
      return getVar(expr[1])[e(2)] = e(3);
    case 'get':
      return getVar(expr[1]);
    case 'set':
      if (!vars.hasOwnProperty(expr[1])) {
        runError('trying to set undeclared variable ' + expr[1]);
      }
      return vars[expr[1]] = e(2);
    case 'var':
      if (vars.hasOwnProperty(expr[1])) {
        runError('may cause a bug if you redeclare function scope variable ' + expr[1]);
      }
      var val;
      if (expr.length > 2) {
        val = e(2);
      }
      return vars[expr[1]] = val;
    default:
      runError('unhandled internal operator ' + expr[0]);
  }
}

function nextSym() {
  var reportError = function(msg) {
    parseError('lexer failure - ' + msg);
  }
  symValue = undefined;
  var m = /^((?:\s*\/\/[^\n]*(?:\n|$)+\s*)*(?:(==|!=|<=|>=|[<>*\/+-])|([\]\[();,={}]|(?:var|if|else|while|function|return)\b)|(\.?)([a-zA-Z_][a-zA-Z0-9_]*)\b|([0-9]+)\b|"((?:[^"\\]|\\.)*)"|$)\s*)((?:.|\n)*?)$/.exec(prog);
  if (m) {
    if (m[2] !== undefined) {
      symType = 'binop';
      symValue = m[2];
    } else if (m[3] !== undefined) {
      symType = m[3];
    } else if (m[5] !== undefined) {
      if (m[4]) {
        symType = 'method';
      } else {
        symType = 'ident';
      }
      symValue = m[5];
    } else if ((m[6] !== undefined) || (m[7] !== undefined)) {
      symType = 'literal';
      if (m[6] !== undefined) {
        symValue = parseInt(m[6]);
        if (isNaN(symValue)) {
          reportError('can\'t parse as integer');
        }
      } else {
        symValue = m[7];
      }
    } else {
      symType = '';
    }
    row += m[1].split('\n').length - 1;
    var i = m[1].lastIndexOf('\n');
    if (i >= 0) {
      col = m[1].length - i - 1;
    } else {
      col += m[1].length;
    }
    prog = m[8];
  } else {
    reportError('unknown token ');
  }
}

function accept(needTyp) {
  var value;
  if (symType === needTyp) {
    if (symValue === undefined) {
      value = true;
    } else {
      value = symValue;
    }
    nextSym();
  }
  return value;
}

function expect(needTyp) {
  var value = accept(needTyp);
  if (value === undefined) {
    var next = (symValue === undefined) ? '' : ' (' + symValue + ')';
    parseError('expect: unexpected symbol ' + symType + next + ', expected: ' + needTyp);
  }
  return value;
}

function parseError(msg) {
  var next = prog.split('\n')[0].substr(0, 17);
  if (next.length > 16) {
    next = next.substr(0, 16) + '...';
  }
  error('parse error at row ' + (row + 1) + ' column ' + (col + 1) + ' ' + msg + ', line remaining: ' + next);
}

function runError(msg) {
  error('runtime error ' + msg);
}

function error(msg) {
  var out = document.getElementById('output');
  out.classList.add('error');
  out.value += msg + '\n';
  throw new Error(msg);
}

init();
})();
// ]]>
</script>
</body>
</html>
