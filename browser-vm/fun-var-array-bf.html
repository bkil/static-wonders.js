<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <title>JavaScript subset for Brainfuck interpreter: array, locals</title>
  <link rel='shortcut icon' type=image/x-icon href=data:image/x-icon;, />
  <meta property='og:description' content='Minimalist client side scripting experiment of gemini-web' name='description'>
  <meta name=viewport content='width=device-width, initial-scale=1'>
  <meta name=referrer content=no-referrer>
  <style>
html, body {
  height: 100%;
}

textarea {
  overflow-wrap: anywhere;
  width: 100%;
  height: 40%;
}

.error {
  background-color: #fcc;
}
  </style>
</head>
<body>

<h2>Program</h2>
<textarea id=source autofocus>
// <![CDATA[
function skipToLoopEnd(program, startPc) {
  var nest = 1;
  var pc = startPc - 1;
  while (nest > 0) {
    pc = pc + 1;
    if (pc >= program.length) {
      nest = 0
    } else if (program[pc] == "[") {
      nest = nest + 1
    } else if (program[pc] == "]") {
      nest = nest - 1
    }
  };
  return pc
}

function exec(program, read) {
  var pc = 0;
  var rp = 0;
  var output = "";

  var mem = [0];
  var mp = 0;
  var stack = [];
  var sp = 0;
  var c;
  var str;

  while (pc < program.length) {
    c = program[pc];
    pc = pc + 1;
    if (c == "<") {
      mp = mp - 1
    } else if (c == ">") {
      mp = mp + 1;
      if (mem[mp] === undefined) {
        mem[mp] = 0
      }
    } else if (c == "+") {
      mem[mp] = mem[mp] + 1
    } else if (c == "-") {
      mem[mp] = mem[mp] - 1
    } else if (c == ",") {
      if (rp < read.length) {
        str = read[rp];
        mem[mp] = str.charCodeAt(0);
        rp = rp + 1
      } else {
        mem[mp] = 0
      }
    } else if (c == ".") {
      output = output + String.fromCharCode(mem[mp])
    } else if (c == "[") {
      stack[sp] = pc;
      sp = sp + 1;
      pc = skipToLoopEnd(program, pc)
    } else if (c == "]") {
      if (mem[mp] > 0) {
        pc = stack[sp - 1]
      } else {
        sp = sp - 1
      }
    }
  };
  return output
}

var output = exec(
  "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.,[+.,]",
  "aXY"
);
document.write(output)
// ]]>
</textarea>

<h2>Output</h2>
<textarea id=output></textarea>

<button id=runButton type=button disabled>Run</button>

<script>
// <![CDATA[
(function() {
'use strict';
var prog;
var symType;
var symValue;

function init() {
  var runBut = document.getElementById('runButton');
  runBut.onclick = run;
  runBut.disabled = false;
  run();
}

function run() {
  prog = document.getElementById('source').value;
  var out = document.getElementById('output');
  out.classList.remove('error');
  out.value = '';
  var tree = parseProgram();
  out.value = JSON.stringify(tree, null, 2) + '\n';
  evalFun('', [], tree, {});
}

function parseProgram() {
  var ret = {};
  nextSym();
  var mainBody = ['seq'];
  while (!accept('')) {
    if (accept('function')) {
      var name = expect('ident');
      expect('(');
      var param = [];
      if (!accept(')')) {
        do {
          param[param.length] = expect('ident');
        } while (accept(','));
        expect(')');
      }
      expect('{');
      var body = ['seq'];
      var b = 1;
      while (b) {
        var statement;
        if (accept('return')) {
          statement = ['return', parseExpression()];
          accept(';');
          expect('}');
          b = 0;
        } else if (accept('}')) {
          b = 0;
        } else {
          statement = parseStatement();
        }
        body[body.length] = statement;
      }
      ret[name] = [param, body];
    } else {
      mainBody[mainBody.length] = parseStatement();
    }
  }
  ret[''] = [[], mainBody];
  return ret;
}

function evalFun(name, args, tree) {
  var ret;
  if (name == 'parseInt') {
    ret = parseInt(args[0])
  } else if (name == 'isNaN') {
    ret = isNaN(args[0])
  } else {
    var fun = tree[name];
    if (!fun) {
      runError('unknown function ' + name);
    }
    var param = fun[0];
    var vars = {};
    var i = 0;
    while (i < param.length) {
      vars[param[i]] = args[i];
      i = i + 1;
    }
    ret = evalStatement(fun[1], tree, vars);
  }
  return ret
}

function parseStatements() {
  var ret;
  if (accept('{')) {
    var ret = ['seq'];
    while (!accept('}')) {
      ret[ret.length] = parseStatement();
    };
  } else {
    ret = parseStatement();
  }
  return ret;
}

function parseStatement() {
  var ret;
  if (accept('if')) {
    expect('(');
    var ifCond = parseExpression();
    expect(')');
    ret = ['if', ifCond, parseStatements()];
    if (accept('else')) {
      ret[ret.length] = parseStatements();
    }
  } else if (accept('while')) {
    expect('(');
    var whileCond = parseExpression();
    expect(')');
    ret = ['while', whileCond, parseStatements()];
  } else if (accept('var')) {
    ret = ['var', expect('ident')];
    if (accept('=')) {
      ret[ret.length] = parseExpression();
    }
  } else {
    ret = parseExpression();
  }
  accept(';');
  return ret;
}

function evalStatement(statement, tree, vars) {
  var ret;
  switch (statement[0]) {
    case 'seq':
      for (var i = 1; i < statement.length; i++) {
        ret = evalStatement(statement[i], tree, vars);
      }
      break
    case 'return':
      ret = evalExpression(statement[1], tree, vars);
      break
    case 'if':
      if (evalExpression(statement[1], tree, vars)) {
        evalStatement(statement[2], tree, vars);
      } else if (statement[3]) {
        evalStatement(statement[3], tree, vars);
      }
      break
    case 'while':
      while (evalExpression(statement[1], tree, vars)) {
        evalStatement(statement[2], tree, vars);
      }
      break
    default:
      ret = evalExpression(statement, tree, vars);
  }
  return ret;
}

function parseExpression() {
  var ret;
  if (accept('!')) {
    ret = ['!', parseTerm()];
  } else {
    ret = parseTerm();
    var value = accept('binop');
    if (value) {
      ret = [value, ret, parseTerm()];
    }
  }
  return ret;
}

function parseTerm() {
  var ret = [];
  var b;
  var value = accept('literal');
  if (value !== undefined) {
    ret = ['literal', value];
  } else if (accept('undefined')) {
    ret = ['undefined'];
  } else if (accept('[')) {
    ret = ['list'];
    if (!accept(']')) {
      b = 1;
      while (b) {
        ret[ret.length] = parseExpression();
        b = accept(',');
      }
      expect(']');
    }
  } else if (accept('(')) {
    ret = parseExpression();
    expect(')');
  } else {
    value = expect('ident');
    var name = value;
    var method = accept('method');
    if (accept('(')) {
      var param = [];
      if (!accept(')')) {
        do {
          param[param.length] = parseExpression();
        } while (accept(','));
        expect(')');
      }
      if (method) {
        ret = ['method', name, method, param];
      } else {
        ret = ['call', name, param];
      }
    } else {
      var idx;
      if (method) {
        ret = ['prop', name, method];
      } else {
        if (accept('[')) {
          idx = parseExpression();
          expect(']');
        }
        if (accept('=')) {
          if (idx) {
            ret = ['arrset', name, idx];
          } else {
            ret = ['set', name];
          }
          ret[ret.length] = parseExpression();
        } else {
          if (idx) {
            ret = ['arrget', name, idx];
          } else {
            ret = ['get', name];
          }
        }
      }
    }
  }
  return ret;
}

function evalExprArgs(args, tree, vars) {
  var ret = [];
  var i = 0;
  while (i < args.length) {
    ret[i] = evalExpression(args[i], tree, vars);
    i = i + 1;
  }
  return ret;
}

function evalExpression(expr, tree, vars) {
  var e = function(i) {
    return evalExpression(expr[i], tree, vars);
  };
  var getVar = function(n) {
    if (vars.hasOwnProperty(n)) {
      return vars[n];
    }
    runError('trying to get undeclared variable ' + n);
  };
  var ret;
  var i;
  var arr;

  switch (expr[0]) {
    case 'literal':
      return expr[1];
    case 'undefined':
      return undefined;
    case 'list':
      ret = [];
      i = 1;
      while (i < expr.length) {
        ret[i - 1] = e(i);
        i = i + 1;
      }
      return ret;
    case '!':
      return !e(1)
    case '===':
      return e(1) === e(2)
    case '!==':
      return e(1) !== e(2)
    case '==':
      return e(1) == e(2)
    case '!=':
      return e(1) != e(2)
    case '<':
      return e(1) < e(2)
    case '<=':
      return e(1) <= e(2)
    case '>':
      return e(1) > e(2)
    case '>=':
      return e(1) >= e(2)
    case '&&':
      return e(1) && e(2)
    case '||':
      return e(1) || e(2)
    case '+':
      return e(1) + e(2)
    case '-':
      return e(1) - e(2)
    case '*':
      return e(1) * e(2)
    case '/':
      return e(1) / e(2)
    case 'call':
      return evalFun(expr[1], evalExprArgs(expr[2], tree, vars), tree);
    case 'prop':
      switch (expr[2]) {
        case 'length':
          var arr = getVar(expr[1]);
          return arr.length;
        default:
          runError(('unknown property on ' + expr[1]) + (': ' + expr[2]));
      }
    case 'method':
      var a = evalExprArgs(expr[3], tree, vars);
      switch ((expr[1] + '.') + expr[2]) {
        case 'document.write':
          document.getElementById('output').value += a[0] + '\n';
          return
        case 'String.fromCharCode':
          return String.fromCharCode(a[0]);
        default:
          var arr = getVar(expr[1]);
          switch (expr[2]) {
            case 'charCodeAt':
              return arr.charCodeAt(a[0]);
            case 'match':
              return arr.match(a[0]);
            case 'hasOwnProperty':
              return arr.hasOwnProperty(a[0]);
            default:
              runError(('unknown method on ' + expr[1]) + (': ' + expr[2]));
          }
      }
    case 'arrget':
      var arr = getVar(expr[1]);
      return arr[e(2)];
    case 'arrset':
    var arr = getVar(expr[1]);
      return arr[e(2)] = e(3);
    case 'get':
      return getVar(expr[1]);
    case 'set':
      if (!vars.hasOwnProperty(expr[1])) {
        runError('trying to set undeclared variable ' + expr[1]);
      }
      return vars[expr[1]] = e(2);
    case 'var':
      if (vars.hasOwnProperty(expr[1])) {
        runError('may cause a bug if you redeclare function scope variable ' + expr[1]);
      }
      var val;
      if (expr.length > 2) {
        val = e(2);
      }
      return vars[expr[1]] = val;
    default:
      runError('unhandled internal operator ' + expr[0]);
  }
}

function nextSym() {
  symValue = undefined;
  var m = prog.match('^((?:\\s*//[^\\n]*(?:\\n|$)+\\s*)*(?:(===|!==|==|!=|<=|>=|&&|\\|\\||[<>*/+-])|([\\]\\[();,={}!]|(?:var|if|else|while|function|return|undefined)\\b)|(\\.?)([a-zA-Z_][a-zA-Z0-9_]*)\\b|([0-9]+)\\b|\'((?:[^\'\\\\]|\\\\.)*)\'|"((?:[^"\\\\]|\\\\.)*)"|$)\\s*)((?:.|\\n)*?)$');
  if (m) {
    if (m[2]) {
      symType = 'binop';
      symValue = m[2];
    } else if (m[3]) {
      symType = m[3];
    } else if (m[5]) {
      if (m[4]) {
        symType = 'method';
      } else {
        symType = 'ident';
      }
      symValue = m[5];
    } else if ((m[6]) || (m[7] !== undefined) || (m[8] !== undefined)) {
      symType = 'literal';
      if (m[6]) {
        symValue = parseInt(m[6]);
        if (isNaN(symValue)) {
          parseError('lexer failure, can\'t parse as integer');
        }
      } else if (m[7] !== undefined) {
        symValue = m[7];
      } else {
        symValue = m[8];
      }
    } else {
      symType = '';
    }
    prog = m[9];
  } else {
    parseError('lexer failure, unknown token')
  }
}

function accept(needTyp) {
  var value;
  if (symType === needTyp) {
    if (symValue === undefined) {
      value = true;
    } else {
      value = symValue;
    }
    nextSym();
  }
  return value;
}

function expect(needTyp) {
  var value = accept(needTyp);
  if (value === undefined) {
    var next = '';
    if (symValue !== undefined) {
      next = (' (' + symValue) + ')';
    }
    parseError((('expect: unexpected symbol ' + symType) + (next + ', expected: ')) + needTyp);
  }
  return value;
}

function parseError(msg) {
  error(('parse error - ' + msg) + (', line remaining: ' + prog));
}

function runError(msg) {
  error('runtime error ' + msg);
}

function error(msg) {
  var out = document.getElementById('output');
  out.classList.add('error');
  out.value += msg + '\n';
  throw new Error(msg);
}

init();
})();
// ]]>
</script>
</body>
</html>
